<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Tech254 Sizer">
    <title>Tech254 Passport Photo Sizer Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.1.0/docx.min.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #27ae60;
            --danger-color: #e74c3c;
            --purple-color: #9b59b6;
            --orange-color: #f39c12;
            --dark-color: #2c3e50;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f5f7fa;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 5px;
        }
        .brand {
            text-align: center;
            color: var(--primary-color);
            font-weight: bold;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .upload-section, .preview-section {
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-right: 15px;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover {
            opacity: 0.9;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .download-options {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .download-btn {
            background-color: var(--secondary-color);
            padding: 10px 20px;
        }
        .pdf-btn {
            background-color: var(--danger-color);
        }
        .png-btn {
            background-color: var(--primary-color);
        }
        .docx-btn {
            background-color: var(--dark-color);
        }
        .print-btn {
            background-color: var(--purple-color);
        }
        .bg-remove-btn {
            background-color: var(--orange-color);
        }
        .undo-btn {
            background-color: #7f8c8d;
        }
        .redo-btn {
            background-color: #95a5a6;
        }
        canvas {
            max-width: 100%;
            border: 1px solid #ddd;
            margin-top: 10px;
            border-radius: 4px;
        }
        .a4-template {
            width: 210mm;
            height: 297mm;
            background-color: white;
            margin: 0 auto;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
            page-break-after: always;
        }
        .photo-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .draggable-photo {
            position: absolute;
            cursor: move;
            user-select: none;
            box-sizing: border-box;
        }
        .draggable-photo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo-controls {
            position: absolute;
            top: -25px;
            left: 0;
            display: flex;
            gap: 5px;
        }
        .photo-control-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
        }
        @media print {
            body * {
                visibility: hidden;
            }
            .a4-template, .a4-template * {
                visibility: visible;
            }
            .a4-template {
                position: absolute;
                left: 0;
                top: 0;
                width: 210mm;
                height: 297mm;
                box-shadow: none;
                margin: 0;
                padding: 0;
            }
            .no-print {
                display: none;
            }
            .photo-controls {
                display: none;
            }
        }
        .border-controls {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        input[type="range"] {
            width: 100px;
        }
        .bg-removal-tool {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .bg-removal-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .history-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .status-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .layout-options {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .layout-btn {
            background-color: #95a5a6;
        }
        .layout-btn.active {
            background-color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <h1>Passport Photo Sizer Tool</h1>
    <div class="brand">by Tech254 Sizer</div>
    
    <div class="container">
        <div class="upload-section">
            <h2>1. Upload Your Photo</h2>
            <input type="file" id="photoUpload" accept="image/*">
            
            <div class="controls">
                <div class="control-group">
                    <label for="photoWidth">Width (mm):</label>
                    <input type="number" id="photoWidth" value="35" min="10" max="100">
                </div>
                
                <div class="control-group">
                    <label for="photoHeight">Height (mm):</label>
                    <input type="number" id="photoHeight" value="45" min="10" max="100">
                </div>
                
                <div class="control-group">
                    <label for="bgColor">Background:</label>
                    <input type="color" id="bgColor" value="#ffffff">
                </div>
                
                <div class="control-group">
                    <label for="copiesCount">Copies:</label>
                    <input type="number" id="copiesCount" value="4" min="1" max="20">
                </div>
                
                <button id="resizeBtn">Resize Photo</button>
            </div>
            
            <div class="border-controls">
                <h3>Border Settings:</h3>
                <div class="controls">
                    <div class="control-group">
                        <label for="borderSize">Size (mm):</label>
                        <input type="range" id="borderSize" min="0" max="2" step="0.1" value="0.2">
                        <span id="borderSizeValue">0.2mm</span>
                    </div>
                    
                    <div class="control-group">
                        <label for="borderColor">Color:</label>
                        <input type="color" id="borderColor" value="#cccccc">
                    </div>
                    
                    <div class="control-group">
                        <label for="borderType">Style:</label>
                        <select id="borderType">
                            <option value="solid">Solid</option>
                            <option value="dashed" selected>Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="bg-removal-tool">
                <h3>AI Background Removal</h3>
                <p>Automatically remove background with AI technology</p>
                <div class="bg-removal-controls">
                    <button id="removeBgBtn" class="bg-remove-btn">
                        <span id="removeBgText">Remove Background</span>
                        <span id="removeBgSpinner" class="loading" style="display:none;"></span>
                    </button>
                    <button id="resetBgBtn">Reset Image</button>
                </div>
                <div class="history-controls">
                    <button id="undoBtn" class="undo-btn" disabled>Undo</button>
                    <button id="redoBtn" class="redo-btn" disabled>Redo</button>
                </div>
                <div id="statusMessage" class="status-message" style="display:none;"></div>
            </div>
            
            <canvas id="photoCanvas"></canvas>
        </div>
        
        <div class="preview-section">
            <h2>2. A4 Print Preview (<span id="copiesCountDisplay">4</span> copies)</h2>
            
            <div class="layout-options no-print">
                <button id="autoLayoutBtn" class="layout-btn active">Auto Layout</button>
                <button id="manualLayoutBtn" class="layout-btn">Manual Layout</button>
                <button id="gridLayoutBtn" class="layout-btn">Grid Layout</button>
            </div>
            
            <div class="a4-template" id="a4Template">
                <div class="photo-container" id="photoContainer">
                    <!-- Photos will be inserted here as draggable elements -->
                </div>
            </div>
            
            <div class="download-options no-print">
                <button id="downloadPdfBtn" class="download-btn pdf-btn">Download PDF</button>
                <button id="downloadPngBtn" class="download-btn png-btn">Download PNG</button>
                <button id="downloadJpgBtn" class="download-btn">Download JPG</button>
                <button id="downloadDocxBtn" class="download-btn docx-btn">Download DOCX</button>
                <button id="printBtn" class="print-btn">Print</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize jsPDF
        const { jsPDF } = window.jspdf;
        
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const photoUpload = document.getElementById('photoUpload');
            const photoCanvas = document.getElementById('photoCanvas');
            const ctx = photoCanvas.getContext('2d');
            const photoWidthInput = document.getElementById('photoWidth');
            const photoHeightInput = document.getElementById('photoHeight');
            const bgColorInput = document.getElementById('bgColor');
            const copiesCountInput = document.getElementById('copiesCount');
            const copiesCountDisplay = document.getElementById('copiesCountDisplay');
            const resizeBtn = document.getElementById('resizeBtn');
            const removeBgBtn = document.getElementById('removeBgBtn');
            const removeBgText = document.getElementById('removeBgText');
            const removeBgSpinner = document.getElementById('removeBgSpinner');
            const resetBgBtn = document.getElementById('resetBgBtn');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const photoContainer = document.getElementById('photoContainer');
            const downloadPdfBtn = document.getElementById('downloadPdfBtn');
            const downloadPngBtn = document.getElementById('downloadPngBtn');
            const downloadJpgBtn = document.getElementById('downloadJpgBtn');
            const downloadDocxBtn = document.getElementById('downloadDocxBtn');
            const printBtn = document.getElementById('printBtn');
            const statusMessage = document.getElementById('statusMessage');
            const autoLayoutBtn = document.getElementById('autoLayoutBtn');
            const manualLayoutBtn = document.getElementById('manualLayoutBtn');
            const gridLayoutBtn = document.getElementById('gridLayoutBtn');
            
            // Border controls
            const borderSizeInput = document.getElementById('borderSize');
            const borderColorInput = document.getElementById('borderColor');
            const borderTypeInput = document.getElementById('borderType');
            const borderSizeValue = document.getElementById('borderSizeValue');
            
            // State variables
            let originalImage = null;
            let currentImageData = null;
            let resizedImageUrl = null;
            let currentBorderSize = 0.2;
            let currentBorderColor = '#cccccc';
            let currentBorderType = 'dashed';
            let currentLayoutMode = 'auto'; // 'auto', 'manual', 'grid'
            let draggablePhotos = [];
            
            // History stack for undo/redo
            let historyStack = [];
            let currentHistoryIndex = -1;
            const MAX_HISTORY = 20;
            
            // Update copies count display
            copiesCountInput.addEventListener('input', function() {
                copiesCountDisplay.textContent = this.value;
                if (resizedImageUrl) updateA4Template();
            });
            
            // Update border size display
            borderSizeInput.addEventListener('input', function() {
                currentBorderSize = parseFloat(this.value);
                borderSizeValue.textContent = currentBorderSize.toFixed(1) + 'mm';
                if (resizedImageUrl) updatePhotoBorders();
            });
            
            // Update border color
            borderColorInput.addEventListener('input', function() {
                currentBorderColor = this.value;
                if (resizedImageUrl) updatePhotoBorders();
            });
            
            // Update border type
            borderTypeInput.addEventListener('change', function() {
                currentBorderType = this.value;
                if (resizedImageUrl) updatePhotoBorders();
            });
            
            // Layout mode buttons
            autoLayoutBtn.addEventListener('click', function() {
                setLayoutMode('auto');
            });
            
            manualLayoutBtn.addEventListener('click', function() {
                setLayoutMode('manual');
            });
            
            gridLayoutBtn.addEventListener('click', function() {
                setLayoutMode('grid');
            });
            
            function setLayoutMode(mode) {
                currentLayoutMode = mode;
                autoLayoutBtn.classList.remove('active');
                manualLayoutBtn.classList.remove('active');
                gridLayoutBtn.classList.remove('active');
                
                if (mode === 'auto') {
                    autoLayoutBtn.classList.add('active');
                    updateA4Template();
                } else if (mode === 'manual') {
                    manualLayoutBtn.classList.add('active');
                    enableManualLayout();
                } else if (mode === 'grid') {
                    gridLayoutBtn.classList.add('active');
                    updateGridLayout();
                }
            }
            
            // Handle photo upload
            photoUpload.addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    
                    reader.onload = function(event) {
                        originalImage = new Image();
                        originalImage.onload = function() {
                            photoCanvas.width = originalImage.width;
                            photoCanvas.height = originalImage.height;
                            ctx.drawImage(originalImage, 0, 0);
                            // Save initial state to history
                            saveState();
                        };
                        originalImage.src = event.target.result;
                    };
                    
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            
            // Save current canvas state to history
            function saveState() {
                // Clear redo stack when making new changes
                historyStack = historyStack.slice(0, currentHistoryIndex + 1);
                
                // Limit history size
                if (historyStack.length >= MAX_HISTORY) {
                    historyStack.shift();
                } else {
                    currentHistoryIndex++;
                }
                
                // Save current image data
                historyStack.push({
                    imageData: ctx.getImageData(0, 0, photoCanvas.width, photoCanvas.height),
                    imageSrc: photoCanvas.toDataURL()
                });
                
                // Update button states
                updateUndoRedoButtons();
            }
            
            // Update undo/redo button states
            function updateUndoRedoButtons() {
                undoBtn.disabled = currentHistoryIndex <= 0;
                redoBtn.disabled = currentHistoryIndex >= historyStack.length - 1;
            }
            
            // Undo last action
            undoBtn.addEventListener('click', function() {
                if (currentHistoryIndex > 0) {
                    currentHistoryIndex--;
                    restoreState();
                }
            });
            
            // Redo last undone action
            redoBtn.addEventListener('click', function() {
                if (currentHistoryIndex < historyStack.length - 1) {
                    currentHistoryIndex++;
                    restoreState();
                }
            });
            
            // Restore state from history
            function restoreState() {
                const state = historyStack[currentHistoryIndex];
                ctx.putImageData(state.imageData, 0, 0);
                currentImageData = state.imageData;
                updateUndoRedoButtons();
            }
            
            // Remove background using AI (simulated API call)
            removeBgBtn.addEventListener('click', async function() {
                if (!originalImage) {
                    showStatus('Please upload a photo first', 'error');
                    return;
                }
                
                try {
                    // Show loading state
                    removeBgText.textContent = 'Processing...';
                    removeBgSpinner.style.display = 'inline-block';
                    removeBgBtn.disabled = true;
                    statusMessage.style.display = 'none';
                    
                    // Save state before making changes
                    saveState();
                    
                    // Simulate AI background removal (in a real app, you would call an API here)
                    // For demonstration, we'll use a timeout to simulate API delay
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    // Create a temporary canvas for the "AI" processing
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = photoCanvas.width;
                    tempCanvas.height = photoCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Draw the original image
                    tempCtx.drawImage(photoCanvas, 0, 0);
                    
                    // Simulate AI processing by making a "best guess" at the background
                    // In a real implementation, this would be replaced with actual API call to:
                    // 1. Remove.bg API
                    // 2. Cloudinary
                    // 3. Or other AI background removal service
                    
                    // Get image data
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    
                    // Sample "AI" algorithm - this is just a simple simulation
                    // Real implementation would use proper AI segmentation
                    const centerX = Math.floor(tempCanvas.width / 2);
                    const centerY = Math.floor(tempCanvas.height / 2);
                    const edgeThreshold = 0.15; // 15% from edges is considered background
                    
                    for (let y = 0; y < tempCanvas.height; y++) {
                        for (let x = 0; x < tempCanvas.width; x++) {
                            const i = (y * tempCanvas.width + x) * 4;
                            
                            // Determine if pixel is likely background
                            const isEdge = 
                                x < tempCanvas.width * edgeThreshold ||
                                x > tempCanvas.width * (1 - edgeThreshold) ||
                                y < tempCanvas.height * edgeThreshold ||
                                y > tempCanvas.height * (1 - edgeThreshold);
                            
                            // Calculate distance from center
                            const distanceFromCenter = Math.sqrt(
                                Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
                            );
                            const maxDistance = Math.sqrt(
                                Math.pow(centerX, 2) + Math.pow(centerY, 2)
                            );
                            const normalizedDistance = distanceFromCenter / maxDistance;
                            
                            // If pixel is at edges or very different from center, make transparent
                            if (isEdge || normalizedDistance > 0.8) {
                                data[i + 3] = 0; // Set alpha to 0 (transparent)
                            }
                        }
                    }
                    
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // Draw the result back to main canvas
                    ctx.drawImage(tempCanvas, 0, 0);
                    currentImageData = ctx.getImageData(0, 0, photoCanvas.width, photoCanvas.height);
                    
                    showStatus('Background removed successfully!', 'success');
                } catch (error) {
                    console.error('Background removal failed:', error);
                    showStatus('Background removal failed. Please try again.', 'error');
                } finally {
                    // Reset button state
                    removeBgText.textContent = 'Remove Background';
                    removeBgSpinner.style.display = 'none';
                    removeBgBtn.disabled = false;
                }
            });
            
            // Show status message
            function showStatus(message, type) {
                statusMessage.textContent = message;
                statusMessage.className = `status-message ${type}`;
                statusMessage.style.display = 'block';
                
                // Hide after 5 seconds
                setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, 5000);
            }
            
            // Reset image to original
            resetBgBtn.addEventListener('click', function() {
                if (historyStack.length > 0) {
                    saveState(); // Save current state before resetting
                    currentHistoryIndex = 0;
                    restoreState();
                    showStatus('Image reset to original', 'success');
                }
            });
            
            // Resize photo to passport size
            resizeBtn.addEventListener('click', function() {
                if (!originalImage) {
                    showStatus('Please upload a photo first', 'error');
                    return;
                }
                
                const widthMM = parseFloat(photoWidthInput.value);
                const heightMM = parseFloat(photoHeightInput.value);
                const bgColor = bgColorInput.value;
                
                // Calculate pixel dimensions at 300 DPI
                const pxPerMM = 300 / 25.4;
                const widthPx = Math.round(widthMM * pxPerMM);
                const heightPx = Math.round(heightMM * pxPerMM);
                
                // Create a temporary canvas for resizing
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = widthPx;
                tempCanvas.height = heightPx;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Fill with background color
                tempCtx.fillStyle = bgColor;
                tempCtx.fillRect(0, 0, widthPx, heightPx);
                
                // Calculate aspect ratio and position to center the image
                const originalAspect = originalImage.width / originalImage.height;
                const newAspect = widthPx / heightPx;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (originalAspect > newAspect) {
                    // Original is wider than new aspect ratio
                    drawHeight = heightPx;
                    drawWidth = drawHeight * originalAspect;
                    offsetX = (widthPx - drawWidth) / 2;
                    offsetY = 0;
                } else {
                    // Original is taller than new aspect ratio
                    drawWidth = widthPx;
                    drawHeight = drawWidth / originalAspect;
                    offsetX = 0;
                    offsetY = (heightPx - drawHeight) / 2;
                }
                
                // Draw the image centered
                tempCtx.drawImage(photoCanvas, offsetX, offsetY, drawWidth, drawHeight);
                
                // Update the main canvas
                photoCanvas.width = widthPx;
                photoCanvas.height = heightPx;
                ctx.drawImage(tempCanvas, 0, 0);
                
                // Save the resized image URL
                resizedImageUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                
                // Update the A4 template
                updateA4Template();
                
                showStatus('Photo resized successfully!', 'success');
            });
            
            // Update photo borders
            function updatePhotoBorders() {
                const photos = document.querySelectorAll('.draggable-photo');
                photos.forEach(photo => {
                    photo.style.border = `${currentBorderSize}mm ${currentBorderType} ${currentBorderColor}`;
                });
            }
            
            // Create a draggable photo element
            function createDraggablePhoto(id, x, y, width, height) {
                const photoDiv = document.createElement('div');
                photoDiv.className = 'draggable-photo';
                photoDiv.id = `photo-${id}`;
                photoDiv.style.left = `${x}mm`;
                photoDiv.style.top = `${y}mm`;
                photoDiv.style.width = `${width}mm`;
                photoDiv.style.height = `${height}mm`;
                photoDiv.style.border = `${currentBorderSize}mm ${currentBorderType} ${currentBorderColor}`;
                
                const img = document.createElement('img');
                img.src = resizedImageUrl;
                img.alt = `Passport photo ${id}`;
                photoDiv.appendChild(img);
                
                // Add controls
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'photo-controls';
                
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'photo-control-btn';
                deleteBtn.innerHTML = 'Ã—';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    photoDiv.remove();
                    draggablePhotos = draggablePhotos.filter(p => p.id !== id);
                });
                
                const cloneBtn = document.createElement('div');
                cloneBtn.className = 'photo-control-btn';
                cloneBtn.innerHTML = '+';
                cloneBtn.title = 'Duplicate';
                cloneBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newId = draggablePhotos.length > 0 ? Math.max(...draggablePhotos.map(p => p.id)) + 1 : 1;
                    createDraggablePhoto(newId, x + 5, y + 5, width, height);
                    draggablePhotos.push({
                        id: newId,
                        x: x + 5,
                        y: y + 5,
                        width,
                        height
                    });
                });
                
                controlsDiv.appendChild(deleteBtn);
                controlsDiv.appendChild(cloneBtn);
                photoDiv.appendChild(controlsDiv);
                
                // Make draggable
                let isDragging = false;
                let offsetX, offsetY;
                
                photoDiv.addEventListener('mousedown', (e) => {
                    if (e.target === photoDiv || e.target === img) {
                        isDragging = true;
                        offsetX = e.clientX - photoDiv.getBoundingClientRect().left;
                        offsetY = e.clientY - photoDiv.getBoundingClientRect().top;
                        photoDiv.style.zIndex = '100';
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const containerRect = photoContainer.getBoundingClientRect();
                    const containerLeft = containerRect.left;
                    const containerTop = containerRect.top;
                    
                    // Calculate position in mm
                    const newLeft = (e.clientX - containerLeft - offsetX) / (containerRect.width / 210);
                    const newTop = (e.clientY - containerTop - offsetY) / (containerRect.height / 297);
                    
                    // Constrain to container
                    const constrainedLeft = Math.max(0, Math.min(210 - width, newLeft));
                    const constrainedTop = Math.max(0, Math.min(297 - height, newTop));
                    
                    photoDiv.style.left = `${constrainedLeft}mm`;
                    photoDiv.style.top = `${constrainedTop}mm`;
                    
                    // Update position in draggablePhotos array
                    const photoIndex = draggablePhotos.findIndex(p => p.id === id);
                    if (photoIndex !== -1) {
                        draggablePhotos[photoIndex].x = constrainedLeft;
                        draggablePhotos[photoIndex].y = constrainedTop;
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    photoDiv.style.zIndex = '1';
                });
                
                return photoDiv;
            }
            
            // Enable manual layout mode
            function enableManualLayout() {
                photoContainer.innerHTML = '';
                draggablePhotos = [];
                
                const copiesCount = parseInt(copiesCountInput.value);
                const photoWidthMM = parseFloat(photoWidthInput.value);
                const photoHeightMM = parseFloat(photoHeightInput.value);
                
                // Add one photo centered by default
                const initialX = (210 - photoWidthMM) / 2;
                const initialY = (297 - photoHeightMM) / 2;
                
                const photoDiv = createDraggablePhoto(1, initialX, initialY, photoWidthMM, photoHeightMM);
                photoContainer.appendChild(photoDiv);
                
                draggablePhotos.push({
                    id: 1,
                    x: initialX,
                    y: initialY,
                    width: photoWidthMM,
                    height: photoHeightMM
                });
            }
            
            // Update grid layout (starting from top)
            function updateGridLayout() {
                photoContainer.innerHTML = '';
                draggablePhotos = [];
                
                const copiesCount = parseInt(copiesCountInput.value);
                const photoWidthMM = parseFloat(photoWidthInput.value);
                const photoHeightMM = parseFloat(photoHeightInput.value);
                const spacingMM = 2;
                
                // Calculate how many photos fit horizontally
                const photosPerRow = Math.floor(210 / (photoWidthMM + spacingMM));
                
                // Calculate margins to center the grid horizontally
                const totalWidth = photosPerRow * photoWidthMM + (photosPerRow - 1) * spacingMM;
                const leftMargin = (210 - totalWidth) / 2;
                
                // Fixed top margin (15mm from top)
                const topMargin = 15;
                const rowSpacing = 5;
                
                // Add photos in grid from top
                let photoId = 1;
                let currentTop = topMargin;
                
                while (photoId <= copiesCount) {
                    for (let col = 0; col < photosPerRow; col++) {
                        if (photoId > copiesCount) break;
                        
                        const x = leftMargin + col * (photoWidthMM + spacingMM);
                        const y = currentTop;
                        
                        const photoDiv = createDraggablePhoto(photoId, x, y, photoWidthMM, photoHeightMM);
                        photoContainer.appendChild(photoDiv);
                        
                        draggablePhotos.push({
                            id: photoId,
                            x,
                            y,
                            width: photoWidthMM,
                            height: photoHeightMM
                        });
                        
                        photoId++;
                    }
                    
                    // Move to next row
                    currentTop += photoHeightMM + rowSpacing;
                    
                    // Check if we have space for another row
                    if (currentTop + photoHeightMM > 297) break;
                }
            }
            
            // Update the A4 template with optimized layout
            function updateA4Template() {
                if (!resizedImageUrl) return;
                
                const copiesCount = parseInt(copiesCountInput.value);
                copiesCountDisplay.textContent = copiesCount;
                
                // Clear previous photos
                photoContainer.innerHTML = '';
                draggablePhotos = [];
                
                if (currentLayoutMode === 'auto') {
                    updateAutoLayout();
                } else if (currentLayoutMode === 'manual') {
                    enableManualLayout();
                } else if (currentLayoutMode === 'grid') {
                    updateGridLayout();
                }
            }
            
            // Update auto layout (optimized for paper usage)
            function updateAutoLayout() {
                const copiesCount = parseInt(copiesCountInput.value);
                const photoWidthMM = parseFloat(photoWidthInput.value);
                const photoHeightMM = parseFloat(photoHeightInput.value);
                
                // Calculate maximum number of photos that can fit in different orientations
                const landscapeCount = calculateMaxPhotos(photoWidthMM, photoHeightMM);
                const portraitCount = calculateMaxPhotos(photoHeightMM, photoWidthMM);
                
                // Use the orientation that fits more photos
                if (landscapeCount >= portraitCount) {
                    createAutoLayoutPhotos(photoWidthMM, photoHeightMM);
                } else {
                    createAutoLayoutPhotos(photoHeightMM, photoWidthMM, true);
                }
            }
            
            // Calculate maximum number of photos that can fit in given orientation
            function calculateMaxPhotos(width, height) {
                const a4Width = 210;
                const a4Height = 297;
                const spacing = 2;
                
                const horizontalFit = Math.floor(a4Width / (width + spacing));
                const verticalFit = Math.floor(a4Height / (height + spacing));
                
                return horizontalFit * verticalFit;
            }
            
            // Create photos in auto layout
            function createAutoLayoutPhotos(width, height, rotated = false) {
                const copiesCount = parseInt(copiesCountInput.value);
                const a4Width = 210;
                const a4Height = 297;
                const spacing = 2;
                
                // Calculate how many photos fit horizontally and vertically
                const horizontalFit = Math.floor(a4Width / (width + spacing));
                const verticalFit = Math.floor(a4Height / (height + spacing));
                const maxPerPage = horizontalFit * verticalFit;
                
                // Calculate margins to distribute space evenly
                const totalHorizontalSpace = horizontalFit * width + (horizontalFit - 1) * spacing;
                const leftMargin = (a4Width - totalHorizontalSpace) / 2;
                
                const totalVerticalSpace = verticalFit * height + (verticalFit - 1) * spacing;
                const topMargin = (a4Height - totalVerticalSpace) / 2;
                
                // Add photos in grid
                let photoId = 1;
                for (let row = 0; row < verticalFit; row++) {
                    for (let col = 0; col < horizontalFit; col++) {
                        if (photoId > copiesCount) break;
                        
                        const x = leftMargin + col * (width + spacing);
                        const y = topMargin + row * (height + spacing);
                        
                        const photoDiv = createDraggablePhoto(photoId, x, y, width, height);
                        if (rotated) {
                            photoDiv.style.transform = 'rotate(90deg)';
                            photoDiv.style.transformOrigin = 'center';
                        }
                        photoContainer.appendChild(photoDiv);
                        
                        draggablePhotos.push({
                            id: photoId,
                            x,
                            y,
                            width,
                            height,
                            rotated
                        });
                        
                        photoId++;
                    }
                }
            }
            
            // Create A4 template canvas
            async function createA4Canvas() {
                return new Promise((resolve) => {
                    // Create a new canvas for the A4 template
                    const a4Canvas = document.createElement('canvas');
                    const a4Ctx = a4Canvas.getContext('2d');
                    
                    // Set A4 dimensions at 300 DPI
                    const pxPerMM = 300 / 25.4;
                    a4Canvas.width = 210 * pxPerMM;
                    a4Canvas.height = 297 * pxPerMM;
                    
                    // Fill white background
                    a4Ctx.fillStyle = '#ffffff';
                    a4Ctx.fillRect(0, 0, a4Canvas.width, a4Canvas.height);
                    
                    // Load the resized image
                    const img = new Image();
                    img.onload = function() {
                        // Draw all photos from draggablePhotos array
                        draggablePhotos.forEach(photo => {
                            const x = photo.x * pxPerMM;
                            const y = photo.y * pxPerMM;
                            const width = photo.width * pxPerMM;
                            const height = photo.height * pxPerMM;
                            
                            if (photo.rotated) {
                                // Save the context
                                a4Ctx.save();
                                
                                // Move to center of where we want to draw
                                a4Ctx.translate(x + width/2, y + height/2);
                                
                                // Rotate
                                a4Ctx.rotate(Math.PI/2);
                                
                                // Draw the image offset by half its width/height
                                a4Ctx.drawImage(img, -height/2, -width/2, height, width);
                                
                                // Draw border
                                a4Ctx.strokeStyle = currentBorderColor;
                                a4Ctx.lineWidth = currentBorderSize * pxPerMM;
                                
                                // Set line dash pattern based on border type
                                if (currentBorderType === 'dashed') {
                                    a4Ctx.setLineDash([6, 3]);
                                } else if (currentBorderType === 'dotted') {
                                    a4Ctx.setLineDash([2, 2]);
                                } else {
                                    a4Ctx.setLineDash([]);
                                }
                                
                                a4Ctx.strokeRect(-height/2, -width/2, height, width);
                                a4Ctx.setLineDash([]); // Reset to solid line
                                
                                // Restore the context
                                a4Ctx.restore();
                            } else {
                                // Draw the image
                                a4Ctx.drawImage(img, x, y, width, height);
                                
                                // Draw border
                                a4Ctx.strokeStyle = currentBorderColor;
                                a4Ctx.lineWidth = currentBorderSize * pxPerMM;
                                
                                // Set line dash pattern based on border type
                                if (currentBorderType === 'dashed') {
                                    a4Ctx.setLineDash([6, 3]);
                                } else if (currentBorderType === 'dotted') {
                                    a4Ctx.setLineDash([2, 2]);
                                } else {
                                    a4Ctx.setLineDash([]);
                                }
                                
                                a4Ctx.strokeRect(x, y, width, height);
                                a4Ctx.setLineDash([]); // Reset to solid line
                            }
                        });
                        
                        resolve(a4Canvas);
                    };
                    img.src = resizedImageUrl;
                });
            }
            
            // Create DOCX document
            async function createDocx() {
                const { Document, Packer, Paragraph, ImageRun } = window.docx;
                
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = function() {
                        // Create a temporary canvas to get the image data
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        
                        // Get image data URL
                        const imageDataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                        
                        // Create document
                        const doc = new Document({
                            sections: [{
                                properties: {},
                                children: [
                                    new Paragraph({
                                        children: draggablePhotos.map(photo => {
                                            return new ImageRun({
                                                data: imageDataUrl,
                                                transformation: {
                                                    width: photo.width * 360, // 360 = 1mm in Word's units
                                                    height: photo.height * 360,
                                                },
                                                floating: {
                                                    horizontalPosition: {
                                                        offset: photo.x * 360,
                                                    },
                                                    verticalPosition: {
                                                        offset: photo.y * 360,
                                                    },
                                                }
                                            });
                                        })
                                    })
                                ]
                            }]
                        });
                        
                        resolve(doc);
                    };
                    img.src = resizedImageUrl;
                });
            }
            
            // Download as PDF
            downloadPdfBtn.addEventListener('click', async function() {
                if (!resizedImageUrl) {
                    showStatus('Please resize a photo first', 'error');
                    return;
                }
                
                try {
                    const a4Canvas = await createA4Canvas();
                    
                    // Create PDF
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'a4'
                    });
                    
                    // Add canvas image to PDF
                    pdf.addImage(a4Canvas.toDataURL('image/jpeg'), 'JPEG', 0, 0, 210, 297);
                    
                    // Download PDF
                    pdf.save('passport-photos-tech254.pdf');
                    showStatus('PDF downloaded successfully!', 'success');
                } catch (error) {
                    console.error('PDF generation failed:', error);
                    showStatus('Failed to generate PDF', 'error');
                }
            });
            
            // Download as PNG
            downloadPngBtn.addEventListener('click', async function() {
                if (!resizedImageUrl) {
                    showStatus('Please resize a photo first', 'error');
                    return;
                }
                
                try {
                    const a4Canvas = await createA4Canvas();
                    
                    // Download PNG
                    const link = document.createElement('a');
                    link.download = 'passport-photos-tech254.png';
                    link.href = a4Canvas.toDataURL('image/png');
                    link.click();
                    showStatus('PNG downloaded successfully!', 'success');
                } catch (error) {
                    console.error('PNG generation failed:', error);
                    showStatus('Failed to generate PNG', 'error');
                }
            });
            
            // Download as JPG
            downloadJpgBtn.addEventListener('click', async function() {
                if (!resizedImageUrl) {
                    showStatus('Please resize a photo first', 'error');
                    return;
                }
                
                try {
                    const a4Canvas = await createA4Canvas();
                    
                    // Download JPG
                    const link = document.createElement('a');
                    link.download = 'passport-photos-tech254.jpg';
                    link.href = a4Canvas.toDataURL('image/jpeg', 0.9);
                    link.click();
                    showStatus('JPG downloaded successfully!', 'success');
                } catch (error) {
                    console.error('JPG generation failed:', error);
                    showStatus('Failed to generate JPG', 'error');
                }
            });
            
            // Download as DOCX
            downloadDocxBtn.addEventListener('click', async function() {
                if (!resizedImageUrl) {
                    showStatus('Please resize a photo first', 'error');
                    return;
                }
                
                try {
                    const doc = await createDocx();
                    
                    // Generate DOCX file
                    const packer = new Packer();
                    const blob = await packer.toBlob(doc);
                    
                    // Download DOCX
                    const link = document.createElement('a');
                    link.download = 'passport-photos-tech254.docx';
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    
                    // Clean up
                    setTimeout(() => {
                        URL.revokeObjectURL(link.href);
                    }, 100);
                    
                    showStatus('DOCX downloaded successfully!', 'success');
                } catch (error) {
                    console.error('DOCX generation failed:', error);
                    showStatus('Failed to generate DOCX', 'error');
                }
            });
            
            // Print A4 template
            printBtn.addEventListener('click', function() {
                if (!resizedImageUrl) {
                    showStatus('Please resize a photo first', 'error');
                    return;
                }
                window.print();
            });
            
            // Initialize with auto layout
            setLayoutMode('auto');
        });
    </script>
</body>
</html>
